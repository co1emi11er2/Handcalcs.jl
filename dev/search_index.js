var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#Disclaimer","page":"References","title":"Disclaimer","text":"Note that there are 3 macros exported. It is recommended to use @handcalcs mainly. The singular @handcalc macro is used by the @handcalcs macro. You may find @handcalc useful on certain occasions where you don't define a variable. For example:\n\nusing Handcalcs\na = 2\nb = 3\n@handcalc a + b\n\nBesides this use case, @handcalcs macro can be used. The @handfunc macro should not be used anymore.","category":"section"},{"location":"references/#References-2","page":"References","title":"References","text":"","category":"section"},{"location":"references/#Handcalcs.get_handcalcs","page":"References","title":"Handcalcs.get_handcalcs","text":"get_handcalcs()\n\nGet a Dict with the user-specified default kwargs for handcalcs, set by set_handcalcs.\n\nKwargs\n\ncols: sets the number of columns in the output\nspa: sets the line spacing\nlen: can set to :long and it will split equation to multiple lines\nh_env: Choose between \"aligned\" (default), \"align\" and other LaTeX options\nh_render: choose between \"equation\", symbolic\", \"numeric\" and \"both\" (default)\nprecision: formats numbers to a max precision. Given precision = 2, 2.567 will show as 2.57, while 2.5 would show as 2.5\nnot_funcs: Name the functions you do not want to \"unroll\" \nparse_pipe: a boolean value (default=true) to remove pipe from equation. This is intended for unitful equations.\nparse_ifs: a boolean value (default=true) to unroll if statements. Function unrolling works and it only shows the parts of the if statement that were met.\ndisable: disable handcalcs rendering to run simulations and turn it back on when needed.\n\n\n\n\n\n","category":"function"},{"location":"references/#Handcalcs.left_align_in_pluto-Tuple{}","page":"References","title":"Handcalcs.left_align_in_pluto","text":"left_align_in_pluto()\n\nReturns html that changes mathjax settings in pluto. This results in equations that are left aligned instead of centered.\n\n\n\n\n\n","category":"method"},{"location":"references/#Handcalcs.reset_handcalcs-Tuple{}","page":"References","title":"Handcalcs.reset_handcalcs","text":"reset_handcalcs()\n\nReset user-specified default kwargs for handcalcs, set by set_handcalcs.\n\n\n\n\n\n","category":"method"},{"location":"references/#Handcalcs.set_handcalcs-Tuple{}","page":"References","title":"Handcalcs.set_handcalcs","text":"set_default(; kwargs...)\n\nSet default kwarg values for handcalcs. \n\nThis works for all keyword arguments. It is additive such that if you call it multiple times, defaults will be added or replaced, but not reset.\n\nKwargs\n\ncols: sets the number of columns in the output\nspa: sets the line spacing\nlen: can set to :long and it will split equation to multiple lines\ncolor: change the color of the output (:blue, :red, etc)\nprecision: formats numbers to a max precision. Given precision = 2, 2.567 will show as 2.57, while 2.5 would show as 2.5\nh_env: choose between \"aligned\" (default), \"align\" and other LaTeX options\nh_render: choose between \"equation\", symbolic\", \"numeric\" and \"both\" (default)\nnot_funcs: name the functions you do not want to \"unroll\" \nparse_pipe: a boolean value (default=true) to remove pipe from equation. This is intended for unitful equations.\nparse_ifs: a boolean value (default=true) to unroll if statements. Function unrolling works and it only shows the parts of the if statement that were met.\ndisable: disable handcalcs rendering to run simulations and turn it back on when needed.\n\nExample: \n\nset_handcalcs(cols = 2, spa = 5)\n\nTo reset the defaults that you have set, use reset_handcalcs. To see your specified defaults, use get_handcalcs.\n\n\n\n\n\n","category":"method"},{"location":"references/#Handcalcs.@handcalc-Tuple{Any, Vararg{Any}}","page":"References","title":"Handcalcs.@handcalc","text":"@handcalc expression\n\nCreate LaTeXString representing expression. The expression being a vaiable followed by an equals sign and an algebraic equation. Any side effects of the expression, like assignments, are evaluated as well. The RHS can be formatted or otherwise transformed by supplying a function as kwarg post.\n\nExamples\n\njulia> a = 2\n2\njulia> b = 5\n5\njulia> @handcalc c = a + b\nL\"$c = a + b = 2 + 5 = 7$\"\n\njulia> c\n7\n\n\n\n\n\n","category":"macro"},{"location":"references/#Handcalcs.@handcalcs-Tuple{Any, Vararg{Any}}","page":"References","title":"Handcalcs.@handcalcs","text":"@handcalcs(expressions, kwargs)\n\nCreate LaTeXString representing expressions. The expressions representing a number of expressions. A single expression being a vaiable followed by an equals sign and an algebraic equation. Any side effects of the expression, like assignments, are evaluated as well.   The RHS can be formatted or otherwise transformed by supplying a function as kwarg post. Can also add comments to the end of equations. See example below.\n\nKwargs\n\ncols: sets the number of columns in the output\nspa: sets the line spacing\nlen: can set to :long and it will split equation to multiple lines\ncolor: change the color of the output (:blue, :red, etc)\nh_env: choose between \"aligned\" (default), \"align\" and other LaTeX options\nnot_funcs: name the functions you do not want to \"unroll\" \nshow_funcs: true or false (default), helps with debugging when getting error during function unrolling.\n\nExamples\n\njulia> a = 2\n2\n\njulia> b = 5\n5\n\njulia> e = 7\n7\n\njulia> @handcalcs begin \n    c = a + b; \"eq 1\";\n    d = a - c\n    e\nend\nL\"$\\begin{aligned}\nc &= a + b = 2 + 5 = 7\\;\\text{  }(\\text{eq 1})\n\\\\[10pt]\nd &= a - c = 2 - 7 = -5\n\\\\[10pt]\ne &= 7\n\\end{aligned}$\"\n\njulia> c\n7\n\njulia> d\n-5\n\n\n\n\n\n\n","category":"macro"},{"location":"references/#Handcalcs.@handfunc-Tuple{Any, Vararg{Any}}","page":"References","title":"Handcalcs.@handfunc","text":"@handfunc expression\n\nCreate LaTeXString representing expressions. These expressions represent a number of expressions that exist within the function that was called. A single expression being a variable followed by an equals sign and the function being called. The expression is evaluated as well (not the expressions within the function). The RHS can be formatted or otherwise transformed by supplying a function as kwarg post.\n\nExamples\n\njulia> @handfunc Iy = calc_Ix(5, 15)\nL\"$\\begin{aligned}\nIx &= \\frac{b \\cdot h^{3}}{12} = \\frac{5 \\cdot 15^{3}}{12} = 1406.25\n\\end{aligned}$\"\n\njulia> Iy\n1406.25\n\n\nNote how Iy is evaluated but Ix is not.\n\n\n\n\n\n","category":"macro"},{"location":"#Handcalcs","page":"Home","title":"Handcalcs","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"This is the documentation for Handcalcs.jl. This package supplies macros to generate LaTeX formatted strings from mathmatical formulas. This package takes inspiration from handcalcs.py which is a python package that works best in jupyter notebooks. The goal is to get the functionalities of that package and bring them to Julia. At this point, I believe most (if not all) of the features from the python package are here. This package is an extension of Latexify.jl. The @latexdefine macro is similar to the main @handcalcs macro, but instead of only a symbolic rendering it also renders the numeric substitution.\n\nThe package can be used with Unitful.jl and can also be used with Quarto to produce high quality calculations. See the Flexural Design Example for an example.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package is registered in the Julia registry, so to install it you can just run:\n\nPkg.add(\"Handcalcs\")","category":"section"},{"location":"#Basic-example:","page":"Home","title":"Basic example:","text":"","category":"section"},{"location":"#Single-line-expression","page":"Home","title":"Single line expression","text":"using Handcalcs\na = 3\nb = 4\n@handcalcs c = sqrt(a^2 + b^2)","category":"section"},{"location":"#Future-Plans","page":"Home","title":"Future Plans","text":"There are a number of things that I would like to implement to the package. Here is a list of features I hope to add:\n\nMaybe a symbolic mode that would essentially be like @latexdefine but you get function unrolling and multiline support.\nI have also thought about adding a setting that you could change if you were within the REPL and instead of latex (since it is not very readable) to instead output a simple string instead. For example: I_x = b*h^3/12 = 5*15^3/12 = 1406.25.","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"Below are a series of examples of the capabilities of the Handcalcs package.","category":"section"},{"location":"tutorial/#Expression-Examples","page":"Tutorial","title":"Expression Examples","text":"","category":"section"},{"location":"tutorial/#A-single-expression-example:","page":"Tutorial","title":"A single expression example:","text":"using Handcalcs\na = 2\nb = -5\nc = 2\n@handcalcs x = (-b + sqrt(b^2 - 4*a*c))/ (2*a)\n\nThe variable x is still evaluated:\n\nx","category":"section"},{"location":"tutorial/#An-example-of-multiple-expressions:","page":"Tutorial","title":"An example of multiple expressions:","text":"Note: If you input strings instead of expressions into handcalcs, they will be enclosed in parenthesis and added to the end of the last expression line.\n\nb = 5 # width\nh = 15 # height\n@handcalcs begin\n  I_x = (b*h^3)/12; \"moment of inertia about x\";\n  I_y = (h*b^3)/12; \"moment of inertia about y\";\nend\n\nThe I_x and I_y variables are still evaluated:\n\nprintln(\"The moment of inertia about the x direction is: $I_x\\n\nThe moment of inertia about the y direction is: $I_y\\n\")","category":"section"},{"location":"tutorial/#Changing-the-Output-Settings","page":"Tutorial","title":"Changing the Output Settings","text":"You can edit the layout of the returned LaTeX expression with the following kwargs:\n\ncols - change the number of columns the expression returns (default = 1).\nspa - change the vertical line spacing between expressions (default = 10).\ncolor: change the color of the output (:blue, :red, etc)\nh_env - change the environment (default = \"aligned\").\nprecision: formats numbers to a max precision. Given precision = 2, 2.567 will show as 2.57, while 2.5 would show as 2.5\nlen - change expression to write to multiple lines using len=:long (default = :short).\n\nNote: @handcalcs macro can also take symbols of defined variables. See below.\n\na, b, c = 1, 2, 3\n@handcalcs begin\n    a # see note above\n    b\n    c\n    x = 4\n    y = 5\n    z = 6\nend cols=3 spa=0 color=:blue\n\nA list of additional colors can be found here. Not all of the colors in the link work, but a good number of them do.\n\nBelow is an example of what you can do if an expression is really long.\n\na, b, c = 2, -5, 2\n@handcalcs begin\n    x1 = (-b + sqrt(b^2 - 4*a*c))/(2*a)\n    x2 = (-b - sqrt(b^2 - 4*a*c))/(2*a)\nend len = :long # using len argument forces cols=1","category":"section"},{"location":"tutorial/#Function-Examples","page":"Tutorial","title":"Function Examples","text":"The @handcalcs macro will now automatically try to \"unroll\" the expressions within a function when the expression has the following pattern: variable = function_name(args...; kwargs...). Note that this is recursive, so if you have a function that calls other functions where the expressions that call the function are of the format mentioned, it will continue to step into each function to \"unroll\" all expressions.\n\nOne issue that can arise are for the functions that you do not want to unroll. Consider the expression: y = sin(x) or y = x + 5. Both of these expressions match the format: variable = function_name(args...; kwargs...) and would be unrolled. This would result in an error since these functions don't have generic math expressions that can be latexified defining the function. You will need to use the not_funcs keyword to manually tell the @handcalcs macro to pass over these functions. Some of the common math functions that you will not want to unroll are automatically passed over. See examples below.","category":"section"},{"location":"tutorial/#An-example-for-rendering-expressions-within-a-function:","page":"Tutorial","title":"An example for rendering expressions within a function:","text":"function calc_Ix(b, h) # function defined in TestHandcalcFunctions\n    Ix = b*h^3/12\n    return Ix\nend;\n\nusing TestHandcalcFunctions\nb = 5 # width\nh = 15 # height\n@handcalcs Ix = calc_Ix(b, h) # function is defined in TestHandcalcFunctions package\n\nThe Ix variable is evaluated. Ix being the variable assigned in the @handcalcs part (variables within function are not defined in the global name space). If you assign it to a different variable then that will be the variable defined (although you will still see it as Ix in the latex portion). Also note that return statements are filtered out of the function body, so keep relevant parts separate from return statements.\n\nfunction calc_Is(b, h) # function defined in TestHandcalcFunctions\n    Ix = calc_Ix(b, h)\n    Iy = calc_Iy(h, b)\n    return Ix, Iy\nend;\n\nusing TestHandcalcFunctions\nx = 0\n@handcalcs begin\ny = sin(x)\nz = cos(x)\nI_x, I_y = TestHandcalcFunctions.calc_Is(5, 15)\nend not_funcs = [:sin :cos]\n\nIn the above example sin and cos were passed over and calc_Is was not. As you can see, the calc_Is function was a function that called other functions, and the @handcalcs macro continued to step into each function to unroll all expressions. Please see below for a list of the current functions that are passed over automatically. Please submit a pull request if you would like to add more generic math functions that I have left out. \n\nconst math_syms = [\n    :*, :/, :^, :+, :-, :%,\n    :.*, :./, :.^, :.+, :.-, :.%,\n    :<, :>, Symbol(==), :<=, :>=,\n    :.<, :.>, :.==, :.<=, :.>=,\n    :sqrt, :sin, :cos, :tan, :sum, \n    :cumsum, :max, :min, :exp, :log,\n    :log10, :âˆš]\n\nIf you want to add functions to your specific project, you can do the following:\n\nset_handcalcs(not_funcs = [:foo :bar :baz])\n\nCurrent Limitations for @handcalcs\n\nI believe the function needs to be defined in another package. The @code_expr macro from CodeTracking.jl does not see functions in Main for some reason.","category":"section"},{"location":"tutorial/#Debugging-Function-Unrolling","page":"Tutorial","title":"Debugging Function Unrolling","text":"It can be difficult to debug function unrolling when Handcalcs is unable to properly unroll a function. If you encounter an error, you can use the show_funcs keyword. This will print out all the functions Handcalcs stepped into. The last function printed should be where the error occured and it can give you a starting point on where to start digging in.\n\nHere is an example:\n\n@handcalcs begin\nI_x, I_y = TestHandcalcFunctions.calc_Is(5, 15)\nend show_funcs = true\nnothing # writing nothing here to show stdout per Documenter.jl\n\nThere was no error here, but you can see that Handcalcs stepped into calc_Is, then calc_Ix, and then calc_Iy.","category":"section"},{"location":"tutorial/#Options-for-if-statements","page":"Tutorial","title":"Options for if statements","text":"If statements have two different formats in how they can be displayed. The default format is different than how Latexify would display the if statement. The reasoning was to show an if statement more like the way you would if you were performing a calculation by hand and to also integrate function unrolling. The default format (parse_ifs=true), only shows the branches of the if statement that pass the logic statements within the if statement. This is nice, because you only see the equations that are relevant to that specific problem. See the example below:\n\n@handcalcs begin\nx = 10\nif x > 5\n    Ix = calc_Ix(5, 15)\nelse\n    Ix = calc_Ix(10, 15)\nend\nend\n\nNested if statements work as well. See below:\n\n@handcalcs begin\nx = 10\ny = 5\nif x > 5\n    if y < 3\n        Ix = calc_Ix(5, 15)\n    else\n        Ix = calc_Ix(3, 15)\n    end\nelse\n    Ix = calc_Ix(10, 15)\nend\nend\n\nThe other format (parse_ifs=false) looks more like the Latexify format. However, nested ifs don't always work and function unrolling does not work. \n\n@handcalcs begin\nx = 10\ny = 5\nif x > 5\n    Ix = calc_Ix(5, 15)\nelse\n    Ix = calc_Ix(10, 15)\nend\nend parse_ifs=false\n\nYou can also write the if statement like so:\n\n@handcalcs begin\nx = 10\ny = 5\nIx = if x > 5\n    calc_Ix(5, 15)\nelse\n    calc_Ix(10, 15)\nend\nend\n\nThis way does not require you to write the parse_ifs=false, although that may change in future versions. If you prefer the Latexify method you can change the default settings. See next section for more info.","category":"section"},{"location":"tutorial/#Changing-Default-Settings","page":"Tutorial","title":"Changing Default Settings","text":"You can change the default settings using the set_handcalcs function (similar to the set_default function in Latexify).","category":"section"},{"location":"tutorial/#Settings","page":"Tutorial","title":"Settings","text":"cols - change the number of columns the expression returns (default = 1).\nspa - change the vertical line spacing between expressions (default = 10).\nlen: can set to :long and it will split equation to multiple lines\ncolor: change the color of the output (:blue, :red, etc)\nh_env: choose between \"aligned\" (default), \"align\" and other LaTeX options\nh_render: choose between \"equation\", symbolic\", \"numeric\" and \"both\" (default)\nprecision: formats numbers to a max precision. Given precision = 2, 2.567 will show as 2.57, while 2.5 would show as 2.5\nnot_funcs: name the functions you do not want to \"unroll\" \nparse_pipe: a boolean value (default=true) to remove pipe from equation. This is intended for unitful equations.\nparse_ifs: a boolean value (default=true) to unroll if statements. Function unrolling works and it only shows the parts of the if statement that were met.\ndisable: disable handcalcs rendering to run simulations and turn it back on when needed.\n\nset_handcalcs(cols=3)\n\nNote that this changes Handcalcs.jl from within and should therefore only be used in your own Julia sessions (do not call this from within your packages).\n\nThe calls are additive so that a new call with\n\nset_handcalcs(spa = 5)\n\nwill not cancel out the changes we just made to cols. \n\nTo view your changes, use\n\nget_handcalcs()\n\nand to reset your changes, use\n\nreset_handcalcs()","category":"section"},{"location":"tutorial/#Set-default-precision","page":"Tutorial","title":"Set default precision","text":"Handcalcs provides a setting to include a default precision. This setting formats a number to a max precision. See example below:\n\n@handcalcs begin\n    a = 2.567\n    b = 2.5\n    c = 1\n    d = true\nend precision = 2\n\nThis setting is off by default, but you can add a default with the set_handcalcs function.\n\nset_handcalcs(precision=4)\n\nIf other formats are preferred, then use the fmt option provided by Latexify. \n\n@handcalcs begin\n    a = 2.567\n    b = 2.5\n    c = 1\n    d = true\nend fmt = \"%.2f\"\n\nThe set_default function is re-exported from the Latexify.jl package. See here for more Latexify default settings.","category":"section"},{"location":"tutorial/#Set-Rendering-Format","page":"Tutorial","title":"Set Rendering Format","text":"Handcalcs provides a setting to include a different rendering format. The choices are between equation, symbolic, numeric, or both (default).\n\nSee example below for an equation rendering:\n\nset_handcalcs(h_render=:equation)\nb = 5 # width\nh = 15 # height\n@handcalcs Ix = calc_Ix(b, h) # function is defined in TestHandcalcFunctions package\n\nNote: I_x is evaluated.\n\n@handcalcs I_x\n\nSee example below for a symbolic rendering:\n\nset_handcalcs(h_render=:symbolic)\nb = 5 # width\nh = 15 # height\n@handcalcs Ix = calc_Ix(b, h) # function is defined in TestHandcalcFunctions package\n\nSee example below for a numeric rendering:\n\nset_handcalcs(h_render=:numeric)\nb = 5 # width\nh = 15 # height\n@handcalcs Ix = calc_Ix(b, h) # function is defined in TestHandcalcFunctions package\n\nThis is really meant to be a setting overall, but you can use the set_handcalcs function to turn the setting on, then use it again afterward to turn it back to the default.\n\nset_handcalcs(h_render=:both) # set handcalcs back to default","category":"section"},{"location":"tutorial/#Using-Unitful-with-UnitfulLatexify","page":"Tutorial","title":"Using Unitful with UnitfulLatexify","text":"The package integrates with the packages Unitful.jl and UnitfulLatexify.jl. \n\nusing Unitful, UnitfulLatexify\na = 2u\"inch\"\nb = -5u\"inch\"\n@handcalcs c = sqrt(a^2 + b^2)\n\nIf you want to set the units of the output, you can write it the same way you would using Unitful. The @handcalcs macro will parse the |> operator out of the output while still evaluating the result with the conversion.\n\nb = 40u\"ft\"\nt = 8.5u\"inch\"\n@handcalcs begin\n    b\n    t\n    a = b * t       |> u\"inch\"^2\n    Ix = b*t^3/12   |> u\"inch\"^4\nend","category":"section"},{"location":"tutorial/#Pluto","page":"Tutorial","title":"Pluto","text":"Handcalcs renders in Pluto.jl. There is one function specifically for rendering in pluto.\n\nnote: Use `begin` and `end`\nPluto outputs an extra variable description when using @handcalcs without begin and end.As an example:@handcalcs x = 2Instead of writing the code above, write:@handcalcs begin \n    x = 2 \nend","category":"section"},{"location":"tutorial/#Handcalcs.left_align_in_pluto","page":"Tutorial","title":"Handcalcs.left_align_in_pluto","text":"left_align_in_pluto()\n\nReturns html that changes mathjax settings in pluto. This results in equations that are left aligned instead of centered.\n\n\n\n\n\n","category":"function"}]
}
